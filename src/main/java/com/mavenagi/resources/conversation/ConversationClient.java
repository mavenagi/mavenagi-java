/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.resources.conversation;

import com.mavenagi.core.ClientOptions;
import com.mavenagi.core.RequestOptions;
import com.mavenagi.resources.commons.types.ConversationResponse;
import com.mavenagi.resources.commons.types.Feedback;
import com.mavenagi.resources.conversation.requests.ConversationDeleteRequest;
import com.mavenagi.resources.conversation.requests.ConversationGetRequest;
import com.mavenagi.resources.conversation.types.AskObjectRequest;
import com.mavenagi.resources.conversation.types.AskRequest;
import com.mavenagi.resources.conversation.types.CategorizationResponse;
import com.mavenagi.resources.conversation.types.ConversationMessageRequest;
import com.mavenagi.resources.conversation.types.ConversationMetadata;
import com.mavenagi.resources.conversation.types.ConversationPatchRequest;
import com.mavenagi.resources.conversation.types.ConversationRequest;
import com.mavenagi.resources.conversation.types.ConversationsResponse;
import com.mavenagi.resources.conversation.types.ConversationsSearchRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageResponse;
import com.mavenagi.resources.conversation.types.FeedbackRequest;
import com.mavenagi.resources.conversation.types.GenerateMavenSuggestionsRequest;
import com.mavenagi.resources.conversation.types.ObjectStreamResponse;
import com.mavenagi.resources.conversation.types.StreamResponse;
import com.mavenagi.resources.conversation.types.SubmitActionFormRequest;
import com.mavenagi.resources.conversation.types.UpdateMetadataRequest;
import java.util.List;
import java.util.Map;

public class ConversationClient {
    protected final ClientOptions clientOptions;

    private final RawConversationClient rawClient;

    public ConversationClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new RawConversationClient(clientOptions);
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public RawConversationClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public ConversationResponse initialize(ConversationRequest request) {
        return this.rawClient.initialize(request).body();
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public ConversationResponse initialize(ConversationRequest request, RequestOptions requestOptions) {
        return this.rawClient.initialize(request, requestOptions).body();
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public ConversationResponse patch(String conversationId) {
        return this.rawClient.patch(conversationId).body();
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public ConversationResponse patch(String conversationId, ConversationPatchRequest request) {
        return this.rawClient.patch(conversationId, request).body();
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public ConversationResponse patch(
            String conversationId, ConversationPatchRequest request, RequestOptions requestOptions) {
        return this.rawClient.patch(conversationId, request, requestOptions).body();
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(String conversationId) {
        return this.rawClient.get(conversationId).body();
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(String conversationId, ConversationGetRequest request) {
        return this.rawClient.get(conversationId, request).body();
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(
            String conversationId, ConversationGetRequest request, RequestOptions requestOptions) {
        return this.rawClient.get(conversationId, request, requestOptions).body();
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public void delete(String conversationId, ConversationDeleteRequest request) {
        this.rawClient.delete(conversationId, request).body();
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public void delete(String conversationId, ConversationDeleteRequest request, RequestOptions requestOptions) {
        this.rawClient.delete(conversationId, request, requestOptions).body();
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public ConversationResponse appendNewMessages(String conversationId, List<ConversationMessageRequest> request) {
        return this.rawClient.appendNewMessages(conversationId, request).body();
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public ConversationResponse appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request, RequestOptions requestOptions) {
        return this.rawClient
                .appendNewMessages(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public ConversationResponse ask(String conversationId, AskRequest request) {
        return this.rawClient.ask(conversationId, request).body();
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public ConversationResponse ask(String conversationId, AskRequest request, RequestOptions requestOptions) {
        return this.rawClient.ask(conversationId, request, requestOptions).body();
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<StreamResponse> askStream(String conversationId, AskRequest request) {
        return this.rawClient.askStream(conversationId, request).body();
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<StreamResponse> askStream(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        return this.rawClient.askStream(conversationId, request, requestOptions).body();
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public ConversationResponse generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request) {
        return this.rawClient.generateMavenSuggestions(conversationId, request).body();
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public ConversationResponse generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .generateMavenSuggestions(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<ObjectStreamResponse> askObjectStream(String conversationId, AskObjectRequest request) {
        return this.rawClient.askObjectStream(conversationId, request).body();
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<ObjectStreamResponse> askObjectStream(
            String conversationId, AskObjectRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .askObjectStream(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CategorizationResponse categorize(String conversationId) {
        return this.rawClient.categorize(conversationId).body();
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CategorizationResponse categorize(String conversationId, RequestOptions requestOptions) {
        return this.rawClient.categorize(conversationId, requestOptions).body();
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public Feedback createFeedback(FeedbackRequest request) {
        return this.rawClient.createFeedback(request).body();
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public Feedback createFeedback(FeedbackRequest request, RequestOptions requestOptions) {
        return this.rawClient.createFeedback(request, requestOptions).body();
    }

    /**
     * Submit a filled out action form
     */
    public ConversationResponse submitActionForm(String conversationId, SubmitActionFormRequest request) {
        return this.rawClient.submitActionForm(conversationId, request).body();
    }

    /**
     * Submit a filled out action form
     */
    public ConversationResponse submitActionForm(
            String conversationId, SubmitActionFormRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .submitActionForm(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public Map<String, String> addConversationMetadata(String conversationId, Map<String, String> request) {
        return this.rawClient.addConversationMetadata(conversationId, request).body();
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public Map<String, String> addConversationMetadata(
            String conversationId, Map<String, String> request, RequestOptions requestOptions) {
        return this.rawClient
                .addConversationMetadata(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public ConversationMetadata updateConversationMetadata(String conversationId, UpdateMetadataRequest request) {
        return this.rawClient
                .updateConversationMetadata(conversationId, request)
                .body();
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public ConversationMetadata updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .updateConversationMetadata(conversationId, request, requestOptions)
                .body();
    }

    /**
     * Search conversations
     */
    public ConversationsResponse search() {
        return this.rawClient.search().body();
    }

    /**
     * Search conversations
     */
    public ConversationsResponse search(ConversationsSearchRequest request) {
        return this.rawClient.search(request).body();
    }

    /**
     * Search conversations
     */
    public ConversationsResponse search(ConversationsSearchRequest request, RequestOptions requestOptions) {
        return this.rawClient.search(request, requestOptions).body();
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public DeliverMessageResponse deliverMessage(DeliverMessageRequest request) {
        return this.rawClient.deliverMessage(request).body();
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public DeliverMessageResponse deliverMessage(DeliverMessageRequest request, RequestOptions requestOptions) {
        return this.rawClient.deliverMessage(request, requestOptions).body();
    }
}
