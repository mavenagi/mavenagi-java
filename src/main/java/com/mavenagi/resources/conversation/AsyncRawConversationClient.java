/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.resources.conversation;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mavenagi.core.ClientOptions;
import com.mavenagi.core.MavenAGIApiException;
import com.mavenagi.core.MavenAGIException;
import com.mavenagi.core.MavenAGIHttpResponse;
import com.mavenagi.core.MediaTypes;
import com.mavenagi.core.ObjectMappers;
import com.mavenagi.core.QueryStringMapper;
import com.mavenagi.core.RequestOptions;
import com.mavenagi.core.ResponseBodyReader;
import com.mavenagi.core.Stream;
import com.mavenagi.resources.commons.errors.BadRequestError;
import com.mavenagi.resources.commons.errors.NotFoundError;
import com.mavenagi.resources.commons.errors.ServerError;
import com.mavenagi.resources.commons.types.ConversationResponse;
import com.mavenagi.resources.commons.types.ErrorMessage;
import com.mavenagi.resources.commons.types.Feedback;
import com.mavenagi.resources.conversation.requests.ConversationDeleteRequest;
import com.mavenagi.resources.conversation.requests.ConversationGetRequest;
import com.mavenagi.resources.conversation.types.AskRequest;
import com.mavenagi.resources.conversation.types.CategorizationResponse;
import com.mavenagi.resources.conversation.types.ConversationMessageRequest;
import com.mavenagi.resources.conversation.types.ConversationMetadata;
import com.mavenagi.resources.conversation.types.ConversationRequest;
import com.mavenagi.resources.conversation.types.ConversationsResponse;
import com.mavenagi.resources.conversation.types.ConversationsSearchRequest;
import com.mavenagi.resources.conversation.types.FeedbackRequest;
import com.mavenagi.resources.conversation.types.GenerateMavenSuggestionsRequest;
import com.mavenagi.resources.conversation.types.StreamResponse;
import com.mavenagi.resources.conversation.types.SubmitActionFormRequest;
import com.mavenagi.resources.conversation.types.UpdateMetadataRequest;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;
import okhttp3.Call;
import okhttp3.Callback;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;
import org.jetbrains.annotations.NotNull;

public class AsyncRawConversationClient {
    protected final ClientOptions clientOptions;

    public AsyncRawConversationClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> initialize(ConversationRequest request) {
        return initialize(request, null);
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> initialize(
            ConversationRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> get(String conversationId) {
        return get(conversationId, ConversationGetRequest.builder().build());
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> get(
            String conversationId, ConversationGetRequest request) {
        return get(conversationId, request, null);
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> get(
            String conversationId, ConversationGetRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "appId", request.getAppId().get(), false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<Void>> delete(
            String conversationId, ConversationDeleteRequest request) {
        return delete(conversationId, request, null);
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<Void>> delete(
            String conversationId, ConversationDeleteRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "appId", request.getAppId().get(), false);
        }
        QueryStringMapper.addQueryParameter(httpUrl, "reason", request.getReason(), false);
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<Void>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(null, response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request) {
        return appendNewMessages(conversationId, request, null);
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("messages")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> ask(
            String conversationId, AskRequest request) {
        return ask(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> ask(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<Iterable<StreamResponse>>> askStream(
            String conversationId, AskRequest request) {
        return askStream(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<MavenAGIHttpResponse<Iterable<StreamResponse>>> askStream(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask_stream")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<Iterable<StreamResponse>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try {
                    ResponseBody responseBody = response.body();
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                new Stream<StreamResponse>(
                                        StreamResponse.class, new ResponseBodyReader(response), "\n"),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request) {
        return generateMavenSuggestions(conversationId, request, null);
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("generate_maven_suggestions")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CompletableFuture<MavenAGIHttpResponse<CategorizationResponse>> categorize(String conversationId) {
        return categorize(conversationId, null);
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CompletableFuture<MavenAGIHttpResponse<CategorizationResponse>> categorize(
            String conversationId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("categorize")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<CategorizationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), CategorizationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public CompletableFuture<MavenAGIHttpResponse<Feedback>> createFeedback(FeedbackRequest request) {
        return createFeedback(request, null);
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public CompletableFuture<MavenAGIHttpResponse<Feedback>> createFeedback(
            FeedbackRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("feedback")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<Feedback>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), Feedback.class), response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Submit a filled out action form
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> submitActionForm(
            String conversationId, SubmitActionFormRequest request) {
        return submitActionForm(conversationId, request, null);
    }

    /**
     * Submit a filled out action form
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> submitActionForm(
            String conversationId, SubmitActionFormRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("submit-form")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<Map<String, String>>> addConversationMetadata(
            String conversationId, Map<String, String> request) {
        return addConversationMetadata(conversationId, request, null);
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<Map<String, String>>> addConversationMetadata(
            String conversationId, Map<String, String> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<Map<String, String>>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(
                                        responseBody.string(), new TypeReference<Map<String, String>>() {}),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationMetadata>> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request) {
        return updateConversationMetadata(conversationId, request, null);
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationMetadata>> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationMetadata>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationMetadata.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }

    /**
     * Search conversations
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationsResponse>> search() {
        return search(ConversationsSearchRequest.builder().build());
    }

    /**
     * Search conversations
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationsResponse>> search(ConversationsSearchRequest request) {
        return search(request, null);
    }

    /**
     * Search conversations
     */
    public CompletableFuture<MavenAGIHttpResponse<ConversationsResponse>> search(
            ConversationsSearchRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("search")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        CompletableFuture<MavenAGIHttpResponse<ConversationsResponse>> future = new CompletableFuture<>();
        client.newCall(okhttpRequest).enqueue(new Callback() {
            @Override
            public void onResponse(@NotNull Call call, @NotNull Response response) throws IOException {
                try (ResponseBody responseBody = response.body()) {
                    if (response.isSuccessful()) {
                        future.complete(new MavenAGIHttpResponse<>(
                                ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationsResponse.class),
                                response));
                        return;
                    }
                    String responseBodyString = responseBody != null ? responseBody.string() : "{}";
                    try {
                        switch (response.code()) {
                            case 400:
                                future.completeExceptionally(new BadRequestError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 404:
                                future.completeExceptionally(new NotFoundError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                            case 500:
                                future.completeExceptionally(new ServerError(
                                        ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class),
                                        response));
                                return;
                        }
                    } catch (JsonProcessingException ignored) {
                        // unable to map error response, throwing generic error
                    }
                    future.completeExceptionally(new MavenAGIApiException(
                            "Error with status code " + response.code(),
                            response.code(),
                            ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                            response));
                    return;
                } catch (IOException e) {
                    future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
                }
            }

            @Override
            public void onFailure(@NotNull Call call, @NotNull IOException e) {
                future.completeExceptionally(new MavenAGIException("Network error executing HTTP request", e));
            }
        });
        return future;
    }
}
