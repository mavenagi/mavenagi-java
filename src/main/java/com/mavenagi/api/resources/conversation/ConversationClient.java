/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.api.resources.conversation;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mavenagi.api.core.ClientOptions;
import com.mavenagi.api.core.MavenAGIApiException;
import com.mavenagi.api.core.MavenAGIException;
import com.mavenagi.api.core.MediaTypes;
import com.mavenagi.api.core.ObjectMappers;
import com.mavenagi.api.core.RequestOptions;
import com.mavenagi.api.core.ResponseBodyReader;
import com.mavenagi.api.core.Stream;
import com.mavenagi.api.resources.commons.errors.BadRequestError;
import com.mavenagi.api.resources.commons.errors.NotFoundError;
import com.mavenagi.api.resources.commons.errors.ServerError;
import com.mavenagi.api.resources.commons.types.ConversationResponse;
import com.mavenagi.api.resources.commons.types.ErrorMessage;
import com.mavenagi.api.resources.commons.types.Feedback;
import com.mavenagi.api.resources.conversation.requests.ConversationDeleteRequest;
import com.mavenagi.api.resources.conversation.requests.ConversationGetRequest;
import com.mavenagi.api.resources.conversation.types.AskRequest;
import com.mavenagi.api.resources.conversation.types.CategorizationResponse;
import com.mavenagi.api.resources.conversation.types.ConversationMessageRequest;
import com.mavenagi.api.resources.conversation.types.ConversationMetadata;
import com.mavenagi.api.resources.conversation.types.ConversationRequest;
import com.mavenagi.api.resources.conversation.types.FeedbackRequest;
import com.mavenagi.api.resources.conversation.types.GenerateMavenSuggestionsRequest;
import com.mavenagi.api.resources.conversation.types.StreamResponse;
import com.mavenagi.api.resources.conversation.types.SubmitActionFormRequest;
import com.mavenagi.api.resources.conversation.types.UpdateMetadataRequest;
import java.io.IOException;
import java.util.List;
import java.util.Map;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class ConversationClient {
    protected final ClientOptions clientOptions;

    public ConversationClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Initialize a new conversation. Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     */
    public ConversationResponse initialize(ConversationRequest request) {
        return initialize(request, null);
    }

    /**
     * Initialize a new conversation. Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     */
    public ConversationResponse initialize(ConversationRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(String conversationId) {
        return get(conversationId, ConversationGetRequest.builder().build());
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(String conversationId, ConversationGetRequest request) {
        return get(conversationId, request, null);
    }

    /**
     * Get a conversation
     */
    public ConversationResponse get(
            String conversationId, ConversationGetRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            httpUrl.addQueryParameter("appId", request.getAppId().get());
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public void delete(String conversationId, ConversationDeleteRequest request) {
        delete(conversationId, request, null);
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public void delete(String conversationId, ConversationDeleteRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            httpUrl.addQueryParameter("appId", request.getAppId().get());
        }
        httpUrl.addQueryParameter("reason", request.getReason());
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)));
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return;
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public ConversationResponse appendNewMessages(String conversationId, List<ConversationMessageRequest> request) {
        return appendNewMessages(conversationId, request, null);
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public ConversationResponse appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("messages")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public ConversationResponse ask(String conversationId, AskRequest request) {
        return ask(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public ConversationResponse ask(String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<StreamResponse> askStream(String conversationId, AskRequest request) {
        return askStream(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public Iterable<StreamResponse> askStream(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask_stream")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try {
            Response response = client.newCall(okhttpRequest).execute();
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new Stream<StreamResponse>(StreamResponse.class, new ResponseBodyReader(response), "\n");
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public ConversationResponse generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request) {
        return generateMavenSuggestions(conversationId, request, null);
    }

    /**
     * This method is deprecated and will be removed in a future release. Use either <code>ask</code> or <code>askStream</code> instead.
     */
    public ConversationResponse generateMavenSuggestions(
            String conversationId, GenerateMavenSuggestionsRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("generate_maven_suggestions")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CategorizationResponse categorize(String conversationId) {
        return categorize(conversationId, null);
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CategorizationResponse categorize(String conversationId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("categorize")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), CategorizationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public Feedback createFeedback(FeedbackRequest request) {
        return createFeedback(request, null);
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public Feedback createFeedback(FeedbackRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("feedback")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), Feedback.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Submit a filled out action form
     */
    public ConversationResponse submitActionForm(String conversationId, SubmitActionFormRequest request) {
        return submitActionForm(conversationId, request, null);
    }

    /**
     * Submit a filled out action form
     */
    public ConversationResponse submitActionForm(
            String conversationId, SubmitActionFormRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("submit-form")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public Map<String, String> addConversationMetadata(String conversationId, Map<String, String> request) {
        return addConversationMetadata(conversationId, request, null);
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public Map<String, String> addConversationMetadata(
            String conversationId, Map<String, String> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(
                        responseBody.string(), new TypeReference<Map<String, String>>() {});
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public ConversationMetadata updateConversationMetadata(String conversationId, UpdateMetadataRequest request) {
        return updateConversationMetadata(conversationId, request, null);
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public ConversationMetadata updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationMetadata.class);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class));
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class));
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }
}
