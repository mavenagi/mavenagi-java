/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.api.resources.analytics.types;

import com.fasterxml.jackson.annotation.JsonAnyGetter;
import com.fasterxml.jackson.annotation.JsonAnySetter;
import com.fasterxml.jackson.annotation.JsonIgnoreProperties;
import com.fasterxml.jackson.annotation.JsonInclude;
import com.fasterxml.jackson.annotation.JsonProperty;
import com.fasterxml.jackson.annotation.JsonSetter;
import com.fasterxml.jackson.annotation.Nulls;
import com.fasterxml.jackson.databind.annotation.JsonDeserialize;
import com.mavenagi.api.core.ObjectMappers;
import com.mavenagi.api.resources.conversation.types.ConversationFilter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Optional;

@JsonInclude(JsonInclude.Include.NON_ABSENT)
@JsonDeserialize(builder = ConversationTableRequest.Builder.class)
public final class ConversationTableRequest implements IConversationAnalyticsRequest {
    private final Optional<ConversationFilter> conversationFilter;

    private final Optional<TimeInterval> timeGrouping;

    private final List<ConversationGroupBy> fieldGroupings;

    private final List<ConversationColumnDefinition> columnDefinitions;

    private final Map<String, Object> additionalProperties;

    private ConversationTableRequest(
            Optional<ConversationFilter> conversationFilter,
            Optional<TimeInterval> timeGrouping,
            List<ConversationGroupBy> fieldGroupings,
            List<ConversationColumnDefinition> columnDefinitions,
            Map<String, Object> additionalProperties) {
        this.conversationFilter = conversationFilter;
        this.timeGrouping = timeGrouping;
        this.fieldGroupings = fieldGroupings;
        this.columnDefinitions = columnDefinitions;
        this.additionalProperties = additionalProperties;
    }

    /**
     * @return Optional filter applied to refine the conversation data before processing.
     */
    @JsonProperty("conversationFilter")
    @java.lang.Override
    public Optional<ConversationFilter> getConversationFilter() {
        return conversationFilter;
    }

    /**
     * @return Defines the time interval for grouping data. If specified, data is grouped accordingly  based on the time they were created. Example: If set to &quot;DAY,&quot; data will be aggregated by day.
     */
    @JsonProperty("timeGrouping")
    public Optional<TimeInterval> getTimeGrouping() {
        return timeGrouping;
    }

    /**
     * @return Specifies the fields by which data should be grouped. Each unique combination forms a row.
     * If multiple fields are provided, the result is grouped by their unique value combinations.
     * If empty, all data is aggregated into a single row. |
     * Note: The field <code>CreatedAt</code> should not be used here, all time-based grouping should be done using the <code>timeGrouping</code> field.
     */
    @JsonProperty("fieldGroupings")
    public List<ConversationGroupBy> getFieldGroupings() {
        return fieldGroupings;
    }

    /**
     * @return Specifies the metrics to be displayed as columns. Column headers act as keys, with computed metric values as their mapped values. There needs to be at least one column definition in the table request.
     */
    @JsonProperty("columnDefinitions")
    public List<ConversationColumnDefinition> getColumnDefinitions() {
        return columnDefinitions;
    }

    @java.lang.Override
    public boolean equals(Object other) {
        if (this == other) return true;
        return other instanceof ConversationTableRequest && equalTo((ConversationTableRequest) other);
    }

    @JsonAnyGetter
    public Map<String, Object> getAdditionalProperties() {
        return this.additionalProperties;
    }

    private boolean equalTo(ConversationTableRequest other) {
        return conversationFilter.equals(other.conversationFilter)
                && timeGrouping.equals(other.timeGrouping)
                && fieldGroupings.equals(other.fieldGroupings)
                && columnDefinitions.equals(other.columnDefinitions);
    }

    @java.lang.Override
    public int hashCode() {
        return Objects.hash(this.conversationFilter, this.timeGrouping, this.fieldGroupings, this.columnDefinitions);
    }

    @java.lang.Override
    public String toString() {
        return ObjectMappers.stringify(this);
    }

    public static Builder builder() {
        return new Builder();
    }

    @JsonIgnoreProperties(ignoreUnknown = true)
    public static final class Builder {
        private Optional<ConversationFilter> conversationFilter = Optional.empty();

        private Optional<TimeInterval> timeGrouping = Optional.empty();

        private List<ConversationGroupBy> fieldGroupings = new ArrayList<>();

        private List<ConversationColumnDefinition> columnDefinitions = new ArrayList<>();

        @JsonAnySetter
        private Map<String, Object> additionalProperties = new HashMap<>();

        private Builder() {}

        public Builder from(ConversationTableRequest other) {
            conversationFilter(other.getConversationFilter());
            timeGrouping(other.getTimeGrouping());
            fieldGroupings(other.getFieldGroupings());
            columnDefinitions(other.getColumnDefinitions());
            return this;
        }

        @JsonSetter(value = "conversationFilter", nulls = Nulls.SKIP)
        public Builder conversationFilter(Optional<ConversationFilter> conversationFilter) {
            this.conversationFilter = conversationFilter;
            return this;
        }

        public Builder conversationFilter(ConversationFilter conversationFilter) {
            this.conversationFilter = Optional.ofNullable(conversationFilter);
            return this;
        }

        @JsonSetter(value = "timeGrouping", nulls = Nulls.SKIP)
        public Builder timeGrouping(Optional<TimeInterval> timeGrouping) {
            this.timeGrouping = timeGrouping;
            return this;
        }

        public Builder timeGrouping(TimeInterval timeGrouping) {
            this.timeGrouping = Optional.ofNullable(timeGrouping);
            return this;
        }

        @JsonSetter(value = "fieldGroupings", nulls = Nulls.SKIP)
        public Builder fieldGroupings(List<ConversationGroupBy> fieldGroupings) {
            this.fieldGroupings.clear();
            this.fieldGroupings.addAll(fieldGroupings);
            return this;
        }

        public Builder addFieldGroupings(ConversationGroupBy fieldGroupings) {
            this.fieldGroupings.add(fieldGroupings);
            return this;
        }

        public Builder addAllFieldGroupings(List<ConversationGroupBy> fieldGroupings) {
            this.fieldGroupings.addAll(fieldGroupings);
            return this;
        }

        @JsonSetter(value = "columnDefinitions", nulls = Nulls.SKIP)
        public Builder columnDefinitions(List<ConversationColumnDefinition> columnDefinitions) {
            this.columnDefinitions.clear();
            this.columnDefinitions.addAll(columnDefinitions);
            return this;
        }

        public Builder addColumnDefinitions(ConversationColumnDefinition columnDefinitions) {
            this.columnDefinitions.add(columnDefinitions);
            return this;
        }

        public Builder addAllColumnDefinitions(List<ConversationColumnDefinition> columnDefinitions) {
            this.columnDefinitions.addAll(columnDefinitions);
            return this;
        }

        public ConversationTableRequest build() {
            return new ConversationTableRequest(
                    conversationFilter, timeGrouping, fieldGroupings, columnDefinitions, additionalProperties);
        }
    }
}
