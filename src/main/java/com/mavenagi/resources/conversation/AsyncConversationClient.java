/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.resources.conversation;

import com.mavenagi.core.ClientOptions;
import com.mavenagi.core.RequestOptions;
import com.mavenagi.resources.commons.types.ConversationResponse;
import com.mavenagi.resources.commons.types.Feedback;
import com.mavenagi.resources.conversation.requests.ConversationDeleteRequest;
import com.mavenagi.resources.conversation.requests.ConversationGetRequest;
import com.mavenagi.resources.conversation.types.AskObjectRequest;
import com.mavenagi.resources.conversation.types.AskRequest;
import com.mavenagi.resources.conversation.types.CategorizationResponse;
import com.mavenagi.resources.conversation.types.ConversationMessageRequest;
import com.mavenagi.resources.conversation.types.ConversationMetadata;
import com.mavenagi.resources.conversation.types.ConversationPatchRequest;
import com.mavenagi.resources.conversation.types.ConversationRequest;
import com.mavenagi.resources.conversation.types.ConversationsResponse;
import com.mavenagi.resources.conversation.types.ConversationsSearchRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageResponse;
import com.mavenagi.resources.conversation.types.FeedbackRequest;
import com.mavenagi.resources.conversation.types.ObjectStreamResponse;
import com.mavenagi.resources.conversation.types.StreamResponse;
import com.mavenagi.resources.conversation.types.SubmitActionFormRequest;
import com.mavenagi.resources.conversation.types.UpdateMetadataRequest;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CompletableFuture;

public class AsyncConversationClient {
    protected final ClientOptions clientOptions;

    private final AsyncRawConversationClient rawClient;

    public AsyncConversationClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
        this.rawClient = new AsyncRawConversationClient(clientOptions);
    }

    /**
     * Get responses with HTTP metadata like headers
     */
    public AsyncRawConversationClient withRawResponse() {
        return this.rawClient;
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public CompletableFuture<ConversationResponse> initialize(ConversationRequest request) {
        return this.rawClient.initialize(request).thenApply(response -> response.body());
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public CompletableFuture<ConversationResponse> initialize(
            ConversationRequest request, RequestOptions requestOptions) {
        return this.rawClient.initialize(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public CompletableFuture<ConversationResponse> patch(String conversationId) {
        return this.rawClient.patch(conversationId).thenApply(response -> response.body());
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public CompletableFuture<ConversationResponse> patch(String conversationId, ConversationPatchRequest request) {
        return this.rawClient.patch(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public CompletableFuture<ConversationResponse> patch(
            String conversationId, ConversationPatchRequest request, RequestOptions requestOptions) {
        return this.rawClient.patch(conversationId, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<ConversationResponse> get(String conversationId) {
        return this.rawClient.get(conversationId).thenApply(response -> response.body());
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<ConversationResponse> get(String conversationId, ConversationGetRequest request) {
        return this.rawClient.get(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Get a conversation
     */
    public CompletableFuture<ConversationResponse> get(
            String conversationId, ConversationGetRequest request, RequestOptions requestOptions) {
        return this.rawClient.get(conversationId, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>Simulation conversations will no longer be visible in search results nor metrics.
     * Non-simulation conversations will remain visible - they can not be fully removed from the system.</p>
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public CompletableFuture<Void> delete(String conversationId, ConversationDeleteRequest request) {
        return this.rawClient.delete(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>Simulation conversations will no longer be visible in search results nor metrics.
     * Non-simulation conversations will remain visible - they can not be fully removed from the system.</p>
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public CompletableFuture<Void> delete(
            String conversationId, ConversationDeleteRequest request, RequestOptions requestOptions) {
        return this.rawClient.delete(conversationId, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public CompletableFuture<ConversationResponse> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request) {
        return this.rawClient.appendNewMessages(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public CompletableFuture<ConversationResponse> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request, RequestOptions requestOptions) {
        return this.rawClient
                .appendNewMessages(conversationId, request, requestOptions)
                .thenApply(response -> response.body());
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<ConversationResponse> ask(String conversationId, AskRequest request) {
        return this.rawClient.ask(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<ConversationResponse> ask(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        return this.rawClient.ask(conversationId, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<Iterable<StreamResponse>> askStream(String conversationId, AskRequest request) {
        return this.rawClient.askStream(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<Iterable<StreamResponse>> askStream(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        return this.rawClient.askStream(conversationId, request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<Iterable<ObjectStreamResponse>> askObjectStream(
            String conversationId, AskObjectRequest request) {
        return this.rawClient.askObjectStream(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public CompletableFuture<Iterable<ObjectStreamResponse>> askObjectStream(
            String conversationId, AskObjectRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .askObjectStream(conversationId, request, requestOptions)
                .thenApply(response -> response.body());
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CompletableFuture<CategorizationResponse> categorize(String conversationId) {
        return this.rawClient.categorize(conversationId).thenApply(response -> response.body());
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public CompletableFuture<CategorizationResponse> categorize(String conversationId, RequestOptions requestOptions) {
        return this.rawClient.categorize(conversationId, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public CompletableFuture<Feedback> createFeedback(FeedbackRequest request) {
        return this.rawClient.createFeedback(request).thenApply(response -> response.body());
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public CompletableFuture<Feedback> createFeedback(FeedbackRequest request, RequestOptions requestOptions) {
        return this.rawClient.createFeedback(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Submit a filled out action form.
     * Action forms can not be submitted more than once, attempting to do so will result in an error.
     * <p>Additionally, form submission is only allowed when the form is the last message in the conversation.
     * Forms should be disabled in surface UI if a conversation continues and they remain unsubmitted.</p>
     */
    public CompletableFuture<ConversationResponse> submitActionForm(
            String conversationId, SubmitActionFormRequest request) {
        return this.rawClient.submitActionForm(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Submit a filled out action form.
     * Action forms can not be submitted more than once, attempting to do so will result in an error.
     * <p>Additionally, form submission is only allowed when the form is the last message in the conversation.
     * Forms should be disabled in surface UI if a conversation continues and they remain unsubmitted.</p>
     */
    public CompletableFuture<ConversationResponse> submitActionForm(
            String conversationId, SubmitActionFormRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .submitActionForm(conversationId, request, requestOptions)
                .thenApply(response -> response.body());
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public CompletableFuture<Map<String, String>> addConversationMetadata(
            String conversationId, Map<String, String> request) {
        return this.rawClient.addConversationMetadata(conversationId, request).thenApply(response -> response.body());
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public CompletableFuture<Map<String, String>> addConversationMetadata(
            String conversationId, Map<String, String> request, RequestOptions requestOptions) {
        return this.rawClient
                .addConversationMetadata(conversationId, request, requestOptions)
                .thenApply(response -> response.body());
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public CompletableFuture<ConversationMetadata> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request) {
        return this.rawClient
                .updateConversationMetadata(conversationId, request)
                .thenApply(response -> response.body());
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public CompletableFuture<ConversationMetadata> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request, RequestOptions requestOptions) {
        return this.rawClient
                .updateConversationMetadata(conversationId, request, requestOptions)
                .thenApply(response -> response.body());
    }

    /**
     * Search conversations
     */
    public CompletableFuture<ConversationsResponse> search() {
        return this.rawClient.search().thenApply(response -> response.body());
    }

    /**
     * Search conversations
     */
    public CompletableFuture<ConversationsResponse> search(ConversationsSearchRequest request) {
        return this.rawClient.search(request).thenApply(response -> response.body());
    }

    /**
     * Search conversations
     */
    public CompletableFuture<ConversationsResponse> search(
            ConversationsSearchRequest request, RequestOptions requestOptions) {
        return this.rawClient.search(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public CompletableFuture<InputStream> export() {
        return this.rawClient.export().thenApply(response -> response.body());
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public CompletableFuture<InputStream> export(ConversationsSearchRequest request) {
        return this.rawClient.export(request).thenApply(response -> response.body());
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public CompletableFuture<InputStream> export(ConversationsSearchRequest request, RequestOptions requestOptions) {
        return this.rawClient.export(request, requestOptions).thenApply(response -> response.body());
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public CompletableFuture<DeliverMessageResponse> deliverMessage(DeliverMessageRequest request) {
        return this.rawClient.deliverMessage(request).thenApply(response -> response.body());
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public CompletableFuture<DeliverMessageResponse> deliverMessage(
            DeliverMessageRequest request, RequestOptions requestOptions) {
        return this.rawClient.deliverMessage(request, requestOptions).thenApply(response -> response.body());
    }
}
