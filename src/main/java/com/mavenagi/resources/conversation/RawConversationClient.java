/**
 * This file was auto-generated by Fern from our API Definition.
 */
package com.mavenagi.resources.conversation;

import com.fasterxml.jackson.core.JsonProcessingException;
import com.fasterxml.jackson.core.type.TypeReference;
import com.mavenagi.core.ClientOptions;
import com.mavenagi.core.MavenAGIApiException;
import com.mavenagi.core.MavenAGIException;
import com.mavenagi.core.MavenAGIHttpResponse;
import com.mavenagi.core.MediaTypes;
import com.mavenagi.core.ObjectMappers;
import com.mavenagi.core.QueryStringMapper;
import com.mavenagi.core.RequestOptions;
import com.mavenagi.core.ResponseBodyInputStream;
import com.mavenagi.core.ResponseBodyReader;
import com.mavenagi.core.Stream;
import com.mavenagi.resources.commons.errors.BadRequestError;
import com.mavenagi.resources.commons.errors.NotFoundError;
import com.mavenagi.resources.commons.errors.ServerError;
import com.mavenagi.resources.commons.types.ConversationResponse;
import com.mavenagi.resources.commons.types.ErrorMessage;
import com.mavenagi.resources.commons.types.Feedback;
import com.mavenagi.resources.conversation.requests.ConversationDeleteRequest;
import com.mavenagi.resources.conversation.requests.ConversationGetRequest;
import com.mavenagi.resources.conversation.types.AskObjectRequest;
import com.mavenagi.resources.conversation.types.AskRequest;
import com.mavenagi.resources.conversation.types.CategorizationResponse;
import com.mavenagi.resources.conversation.types.ConversationMessageRequest;
import com.mavenagi.resources.conversation.types.ConversationMetadata;
import com.mavenagi.resources.conversation.types.ConversationPatchRequest;
import com.mavenagi.resources.conversation.types.ConversationRequest;
import com.mavenagi.resources.conversation.types.ConversationsResponse;
import com.mavenagi.resources.conversation.types.ConversationsSearchRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageRequest;
import com.mavenagi.resources.conversation.types.DeliverMessageResponse;
import com.mavenagi.resources.conversation.types.FeedbackRequest;
import com.mavenagi.resources.conversation.types.ObjectStreamResponse;
import com.mavenagi.resources.conversation.types.StreamResponse;
import com.mavenagi.resources.conversation.types.SubmitActionFormRequest;
import com.mavenagi.resources.conversation.types.UpdateMetadataRequest;
import java.io.IOException;
import java.io.InputStream;
import java.util.List;
import java.util.Map;
import okhttp3.Headers;
import okhttp3.HttpUrl;
import okhttp3.OkHttpClient;
import okhttp3.Request;
import okhttp3.RequestBody;
import okhttp3.Response;
import okhttp3.ResponseBody;

public class RawConversationClient {
    protected final ClientOptions clientOptions;

    public RawConversationClient(ClientOptions clientOptions) {
        this.clientOptions = clientOptions;
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<ConversationResponse> initialize(ConversationRequest request) {
        return initialize(request, null);
    }

    /**
     * Initialize a new conversation.
     * Only required if the ask request wishes to supply conversation level data or when syncing to external systems.
     * <p>Conversations can not be modified using this API. If the conversation already exists then the existing conversation will be returned.</p>
     * <p>After initialization,</p>
     * <ul>
     * <li>metadata can be changed using the <code>updateConversationMetadata</code> API.</li>
     * <li>messages can be added to the conversation with the <code>appendNewMessages</code> or <code>ask</code> APIs.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<ConversationResponse> initialize(
            ConversationRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public MavenAGIHttpResponse<ConversationResponse> patch(String conversationId) {
        return patch(conversationId, ConversationPatchRequest.builder().build());
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public MavenAGIHttpResponse<ConversationResponse> patch(String conversationId, ConversationPatchRequest request) {
        return patch(conversationId, request, null);
    }

    /**
     * Update mutable conversation fields.
     * <p>The <code>appId</code> field can be provided to update a conversation owned by a different app.
     * All other fields will overwrite the existing value on the conversation only if provided.</p>
     */
    public MavenAGIHttpResponse<ConversationResponse> patch(
            String conversationId, ConversationPatchRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PATCH", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get a conversation
     */
    public MavenAGIHttpResponse<ConversationResponse> get(String conversationId) {
        return get(conversationId, ConversationGetRequest.builder().build());
    }

    /**
     * Get a conversation
     */
    public MavenAGIHttpResponse<ConversationResponse> get(String conversationId, ConversationGetRequest request) {
        return get(conversationId, request, null);
    }

    /**
     * Get a conversation
     */
    public MavenAGIHttpResponse<ConversationResponse> get(
            String conversationId, ConversationGetRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "appId", request.getAppId().get(), false);
        }
        if (request.getTranslationLanguage().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl,
                    "translationLanguage",
                    request.getTranslationLanguage().get(),
                    false);
        }
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("GET", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>Simulation conversations will no longer be visible in search results nor metrics.
     * Non-simulation conversations will remain visible - they can not be fully removed from the system.</p>
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public MavenAGIHttpResponse<Void> delete(String conversationId, ConversationDeleteRequest request) {
        return delete(conversationId, request, null);
    }

    /**
     * Wipes a conversation of all user data.
     * The conversation ID will still exist and non-user specific data will still be retained.
     * Attempts to modify or add messages to the conversation will throw an error.
     * <p>Simulation conversations will no longer be visible in search results nor metrics.
     * Non-simulation conversations will remain visible - they can not be fully removed from the system.</p>
     * <p>&lt;Warning&gt;This is a destructive operation and cannot be undone. &lt;br/&gt;&lt;br/&gt;
     * The exact fields cleared include: the conversation subject, userRequest, agentResponse.
     * As well as the text response, followup questions, and backend LLM prompt of all messages.&lt;/Warning&gt;</p>
     */
    public MavenAGIHttpResponse<Void> delete(
            String conversationId, ConversationDeleteRequest request, RequestOptions requestOptions) {
        HttpUrl.Builder httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId);
        if (request.getAppId().isPresent()) {
            QueryStringMapper.addQueryParameter(
                    httpUrl, "appId", request.getAppId().get(), false);
        }
        QueryStringMapper.addQueryParameter(httpUrl, "reason", request.getReason(), false);
        Request.Builder _requestBuilder = new Request.Builder()
                .url(httpUrl.build())
                .method("DELETE", null)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json");
        Request okhttpRequest = _requestBuilder.build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(null, response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public MavenAGIHttpResponse<ConversationResponse> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request) {
        return appendNewMessages(conversationId, request, null);
    }

    /**
     * Append messages to an existing conversation. The conversation must be initialized first. If a message with the same ID already exists, it will be ignored. Messages do not allow modification.
     */
    public MavenAGIHttpResponse<ConversationResponse> appendNewMessages(
            String conversationId, List<ConversationMessageRequest> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("messages")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<ConversationResponse> ask(String conversationId, AskRequest request) {
        return ask(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question. If the user question or its answer already exists,
     * they will be reused and will not be updated. Messages do not allow modification once generated.
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<ConversationResponse> ask(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<Iterable<StreamResponse>> askStream(String conversationId, AskRequest request) {
        return askStream(conversationId, request, null);
    }

    /**
     * Get an answer from Maven for a given user question with a streaming response. The response will be sent as a stream of events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * Action and metadata events should overwrite past data and do not need concatenation.
     * <p>If the user question or its answer already exists, they will be reused and will not be updated.
     * Messages do not allow modification once generated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitation:</p>
     * <ul>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<Iterable<StreamResponse>> askStream(
            String conversationId, AskRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask_stream")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try {
            Response response = client.newCall(okhttpRequest).execute();
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        Stream.fromSse(StreamResponse.class, new ResponseBodyReader(response)), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<Iterable<ObjectStreamResponse>> askObjectStream(
            String conversationId, AskObjectRequest request) {
        return askObjectStream(conversationId, request, null);
    }

    /**
     * Generate a structured object response based on a provided schema and user prompt with a streaming response.
     * The response will be sent as a stream of events containing text, start, and end events.
     * The text portions of stream responses should be concatenated to form the full response text.
     * <p>If the user question and object response already exist, they will be reused and not updated.</p>
     * <p>Concurrency Behavior:</p>
     * <ul>
     * <li>If another API call is made for the same user question while a response is mid-stream, partial answers may be returned.</li>
     * <li>The second caller will receive a truncated or partial response depending on where the first stream is in its processing. The first caller's stream will remain unaffected and continue delivering the full response.</li>
     * </ul>
     * <p>Known Limitations:</p>
     * <ul>
     * <li>Schema enforcement is best-effort and may not guarantee exact conformity.</li>
     * <li>The API does not currently expose metadata indicating whether a response or message is incomplete. This will be addressed in a future update.</li>
     * </ul>
     */
    public MavenAGIHttpResponse<Iterable<ObjectStreamResponse>> askObjectStream(
            String conversationId, AskObjectRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("ask_object_stream")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try {
            Response response = client.newCall(okhttpRequest).execute();
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        Stream.fromSse(ObjectStreamResponse.class, new ResponseBodyReader(response)), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public MavenAGIHttpResponse<CategorizationResponse> categorize(String conversationId) {
        return categorize(conversationId, null);
    }

    /**
     * Uses an LLM flow to categorize the conversation. Experimental.
     */
    public MavenAGIHttpResponse<CategorizationResponse> categorize(
            String conversationId, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("categorize")
                .build();
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", RequestBody.create("", null))
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), CategorizationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public MavenAGIHttpResponse<Feedback> createFeedback(FeedbackRequest request) {
        return createFeedback(request, null);
    }

    /**
     * Update feedback or create it if it doesn't exist
     */
    public MavenAGIHttpResponse<Feedback> createFeedback(FeedbackRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("feedback")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), Feedback.class), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Submit a filled out action form.
     * Action forms can not be submitted more than once, attempting to do so will result in an error.
     * <p>Additionally, form submission is only allowed when the form is the last message in the conversation.
     * Forms should be disabled in surface UI if a conversation continues and they remain unsubmitted.</p>
     */
    public MavenAGIHttpResponse<ConversationResponse> submitActionForm(
            String conversationId, SubmitActionFormRequest request) {
        return submitActionForm(conversationId, request, null);
    }

    /**
     * Submit a filled out action form.
     * Action forms can not be submitted more than once, attempting to do so will result in an error.
     * <p>Additionally, form submission is only allowed when the form is the last message in the conversation.
     * Forms should be disabled in surface UI if a conversation continues and they remain unsubmitted.</p>
     */
    public MavenAGIHttpResponse<ConversationResponse> submitActionForm(
            String conversationId, SubmitActionFormRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("submit-form")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public MavenAGIHttpResponse<Map<String, String>> addConversationMetadata(
            String conversationId, Map<String, String> request) {
        return addConversationMetadata(conversationId, request, null);
    }

    /**
     * Replaced by <code>updateConversationMetadata</code>.
     * <p>Adds metadata to an existing conversation. If a metadata field already exists, it will be overwritten.</p>
     */
    public MavenAGIHttpResponse<Map<String, String>> addConversationMetadata(
            String conversationId, Map<String, String> request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(
                                responseBody.string(), new TypeReference<Map<String, String>>() {}),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public MavenAGIHttpResponse<ConversationMetadata> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request) {
        return updateConversationMetadata(conversationId, request, null);
    }

    /**
     * Update metadata supplied by the calling application for an existing conversation.
     * Does not modify metadata saved by other apps.
     * <p>If a metadata field already exists for the calling app, it will be overwritten.
     * If it does not exist, it will be added. Will not remove metadata fields.</p>
     * <p>Returns all metadata saved by any app on the conversation.</p>
     */
    public MavenAGIHttpResponse<ConversationMetadata> updateConversationMetadata(
            String conversationId, UpdateMetadataRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegment(conversationId)
                .addPathSegments("metadata")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("PUT", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationMetadata.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Search conversations
     */
    public MavenAGIHttpResponse<ConversationsResponse> search() {
        return search(ConversationsSearchRequest.builder().build());
    }

    /**
     * Search conversations
     */
    public MavenAGIHttpResponse<ConversationsResponse> search(ConversationsSearchRequest request) {
        return search(request, null);
    }

    /**
     * Search conversations
     */
    public MavenAGIHttpResponse<ConversationsResponse> search(
            ConversationsSearchRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("search")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), ConversationsResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public MavenAGIHttpResponse<InputStream> export() {
        return export(ConversationsSearchRequest.builder().build());
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public MavenAGIHttpResponse<InputStream> export(ConversationsSearchRequest request) {
        return export(request, null);
    }

    /**
     * Export conversations to a CSV file.
     * <p>This will output a summary of each conversation that matches the supplied filter. A maximum of 10,000 conversations can be exported at a time.</p>
     * <p>For most use cases it is recommended to use the <code>search</code> API instead and convert the JSON response to your desired format.
     * The CSV format may change over time and should not be relied upon by code consumers.</p>
     */
    public MavenAGIHttpResponse<InputStream> export(ConversationsSearchRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("export")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try {
            Response response = client.newCall(okhttpRequest).execute();
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(new ResponseBodyInputStream(response), response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public MavenAGIHttpResponse<DeliverMessageResponse> deliverMessage(DeliverMessageRequest request) {
        return deliverMessage(request, null);
    }

    /**
     * Deliver a message to a user or conversation.
     * <p>&lt;Warning&gt;
     * Currently, messages can only be successfully delivered to conversations with the `ASYNC` capability that are `open`.
     * User message delivery is not yet supported.
     * &lt;/Warning&gt;</p>
     */
    public MavenAGIHttpResponse<DeliverMessageResponse> deliverMessage(
            DeliverMessageRequest request, RequestOptions requestOptions) {
        HttpUrl httpUrl = HttpUrl.parse(this.clientOptions.environment().getUrl())
                .newBuilder()
                .addPathSegments("v1/conversations")
                .addPathSegments("deliver-message")
                .build();
        RequestBody body;
        try {
            body = RequestBody.create(
                    ObjectMappers.JSON_MAPPER.writeValueAsBytes(request), MediaTypes.APPLICATION_JSON);
        } catch (JsonProcessingException e) {
            throw new MavenAGIException("Failed to serialize request", e);
        }
        Request okhttpRequest = new Request.Builder()
                .url(httpUrl)
                .method("POST", body)
                .headers(Headers.of(clientOptions.headers(requestOptions)))
                .addHeader("Content-Type", "application/json")
                .addHeader("Accept", "application/json")
                .build();
        OkHttpClient client = clientOptions.httpClient();
        if (requestOptions != null && requestOptions.getTimeout().isPresent()) {
            client = clientOptions.httpClientWithTimeout(requestOptions);
        }
        try (Response response = client.newCall(okhttpRequest).execute()) {
            ResponseBody responseBody = response.body();
            if (response.isSuccessful()) {
                return new MavenAGIHttpResponse<>(
                        ObjectMappers.JSON_MAPPER.readValue(responseBody.string(), DeliverMessageResponse.class),
                        response);
            }
            String responseBodyString = responseBody != null ? responseBody.string() : "{}";
            try {
                switch (response.code()) {
                    case 400:
                        throw new BadRequestError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 404:
                        throw new NotFoundError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                    case 500:
                        throw new ServerError(
                                ObjectMappers.JSON_MAPPER.readValue(responseBodyString, ErrorMessage.class), response);
                }
            } catch (JsonProcessingException ignored) {
                // unable to map error response, throwing generic error
            }
            throw new MavenAGIApiException(
                    "Error with status code " + response.code(),
                    response.code(),
                    ObjectMappers.JSON_MAPPER.readValue(responseBodyString, Object.class),
                    response);
        } catch (IOException e) {
            throw new MavenAGIException("Network error executing HTTP request", e);
        }
    }
}
